import { DocumentNode, FragmentDefinitionNode, GraphQLSchema, OperationDefinitionNode, OperationTypeNode } from "graphql";
import { ExportedFile } from "./codegen/codegenHelpers";
export declare type State = {
    set: (key: string, value?: any) => any;
    get: (key: string) => any;
};
export declare type NetlifySite = {
    id: string;
};
export declare type NetlifyGraphConfig = {
    functionsPath: string[];
    netlifyGraphImplementationFilename: string[];
    netlifyGraphTypeDefinitionsFilename: string[];
    graphQLOperationsSourceFilename: string[];
    graphQLSchemaFilename: string[];
    netlifyGraphRequirePath: string[];
    netlifyGraphPath: string[];
    framework: string;
    extension: string;
    moduleType: "commonjs" | "esm";
    language: "javascript" | "typescript";
};
export declare type ExtractedFunction = {
    id: string;
    operationName: string;
    description: string;
    kind: OperationTypeNode;
    parsedOperation: OperationDefinitionNode;
    operationString: string;
    operationStringWithoutNetlifyDirective: string;
};
export declare type ParsedFunction = ExtractedFunction & {
    id: string;
    operationString: string;
    description: string;
    fnName: string;
    safeBody: string;
    kind: OperationTypeNode;
    variableSignature: string;
    returnSignature: string;
    operationName: string;
    parsedOperation: OperationDefinitionNode;
};
export declare const defaultSourceOperationsFilename = "netlifyGraphOperationsLibrary.graphql";
export declare const defaultGraphQLSchemaFilename = "netlifyGraphSchema.graphql";
export declare const defaultNetlifyGraphConfig: NetlifyGraphConfig;
export declare const defaultExampleOperationsDoc = "query ExampleQuery @netlify(doc: \"An example query to start with.\") {\n  __typename\n}";
export declare const generateSubscriptionFunctionTypeDefinition: (schema: GraphQLSchema, fn: ParsedFunction, fragments: FragmentDefinitionNode[]) => string;
export declare const generateSubscriptionFunction: (schema: any, fn: any, fragments: any) => string;
export declare const queryToFunctionDefinition: (fullSchema: GraphQLSchema, persistedQuery: ExtractedFunction) => ParsedFunction | undefined;
export declare const generateJavaScriptClient: (netlifyGraphConfig: NetlifyGraphConfig, schema: GraphQLSchema, operationsDoc: string, enabledFunctions: ParsedFunction[]) => string;
export declare const generateTypeScriptDefinitions: (netlifyGraphConfig: NetlifyGraphConfig, schema: GraphQLSchema, enabledFunctions: ParsedFunction[]) => string;
export declare const generateFunctionsSource: (netlifyGraphConfig: NetlifyGraphConfig, schema: GraphQLSchema, operationsDoc: string, queries: ExtractedFunction[]) => {
    clientSource: string;
    typeDefinitionsSource: string;
    functionDefinitions: ParsedFunction[];
};
/**
 * Extracts basic functions from a parsed GraphQL operations document
 * @param {DocumentNode} parsedDoc The parsed GraphQL document with @netlify directives
 * @returns Record<string, ExtractedFunction>
 */
export declare const extractFunctionsFromOperationDoc: (parsedDoc: DocumentNode) => Record<string, ExtractedFunction>;
/**
 * Given a schema, GraphQL operations doc, a target operationId, and a Netlify Graph config, generates a set of handlers (and potentially components) for the correct framework.
 */
export declare const generateHandlerSource: ({ handlerOptions, netlifyGraphConfig, operationId, operationsDoc, schema, }: {
    handlerOptions: Record<string, boolean>;
    netlifyGraphConfig: NetlifyGraphConfig;
    operationId: string;
    operationsDoc: string;
    schema: GraphQLSchema;
}) => {
    exportedFiles: ExportedFile[];
    operation: OperationDefinitionNode;
} | undefined;
