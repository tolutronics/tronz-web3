"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateHandlerSource = exports.extractFunctionsFromOperationDoc = exports.generateFunctionsSource = exports.generateTypeScriptDefinitions = exports.generateJavaScriptClient = exports.queryToFunctionDefinition = exports.generateSubscriptionFunction = exports.generateSubscriptionFunctionTypeDefinition = exports.defaultExampleOperationsDoc = exports.defaultNetlifyGraphConfig = exports.defaultGraphQLSchemaFilename = exports.defaultSourceOperationsFilename = void 0;
var uuid_1 = require("uuid");
var graphql_1 = require("graphql");
var internalConsole_1 = require("./internalConsole");
var graphqlHelpers_1 = require("./graphqlHelpers");
var genericExporter_1 = require("./codegen/genericExporter");
var nextjsExporter_1 = require("./codegen/nextjsExporter");
var capitalizeFirstLetter = function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
};
var replaceAll = function (target, search, replace) {
    var simpleString = search.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return target.replace(new RegExp(simpleString, "g"), replace);
};
exports.defaultSourceOperationsFilename = "netlifyGraphOperationsLibrary.graphql";
exports.defaultGraphQLSchemaFilename = "netlifyGraphSchema.graphql";
exports.defaultNetlifyGraphConfig = {
    extension: "js",
    functionsPath: ["netlify", "functions"],
    netlifyGraphPath: ["netlify", "functions", "netlifyGraph"],
    netlifyGraphImplementationFilename: [
        "netlify",
        "functions",
        "netlifyGraph",
        "index.js",
    ],
    netlifyGraphTypeDefinitionsFilename: [
        "netlify",
        "functions",
        "netlifyGraph",
        "index.d.ts",
    ],
    graphQLOperationsSourceFilename: [
        "netlify",
        "functions",
        "netlifyGraph",
        exports.defaultSourceOperationsFilename,
    ],
    graphQLSchemaFilename: [
        "netlify",
        "functions",
        "netlifyGraph",
        exports.defaultGraphQLSchemaFilename,
    ],
    netlifyGraphRequirePath: ["./netlifyGraph"],
    framework: "custom",
    moduleType: "commonjs",
    language: "javascript",
};
exports.defaultExampleOperationsDoc = "query ExampleQuery @netlify(doc: \"An example query to start with.\") {\n  __typename\n}";
var generatedOneGraphClient = function () {
    return "\nconst fetch = (appId, options) => {\n  var reqBody = options.body || null\n  const userHeaders = options.headers || {}\n  const headers = {\n    ...userHeaders,\n    'Content-Type': 'application/json',\n    'Content-Length': reqBody.length,\n  }\n\n  var reqOptions = {\n    method: 'POST',\n    headers: headers,\n    timeout: 30000,\n  }\n\n  const url = 'https://serve.onegraph.com/graphql?app_id=' + appId\n\n  const respBody = []\n\n  return new Promise((resolve, reject) => {\n    var req = https.request(url, reqOptions, (res) => {\n      if (res.statusCode < 200 || res.statusCode > 299) {\n        return reject(\n          new Error(\n            \"Netlify OneGraph return non - OK HTTP status code\" + res.statusCode,\n          ),\n        )\n      }\n\n      res.on('data', (chunk) => respBody.push(chunk))\n\n      res.on('end', () => {\n        const resString = Buffer.concat(respBody).toString()\n        resolve(resString)\n      })\n    })\n\n    req.on('error', (e) => {\n      console.error('Error making request to Netlify OneGraph: ', e)\n    })\n\n    req.on('timeout', () => {\n      req.destroy()\n      reject(new Error('Request to Netlify OneGraph timed out'))\n    })\n\n    req.write(reqBody)\n    req.end()\n  })\n}\n\nconst fetchOneGraphPersisted = async function fetchOneGraphPersisted(\n  accessToken,\n  docId,\n  operationName,\n  variables,\n) {\n  const payload = {\n    doc_id: docId,\n    variables: variables,\n    operationName: operationName,\n  }\n\n  const result = await fetch(\n    process.env.SITE_ID,\n    {\n      method: 'POST',\n      headers: {\n        Authorization: accessToken ? \"Bearer \" + accessToken : '',\n      },\n      body: JSON.stringify(payload),\n    },\n  )\n\n  // @ts-ignore\n  return JSON.parse(result)\n}\n\nconst fetchOneGraph = async function fetchOneGraph(\n  accessToken,\n  query,\n  operationName,\n  variables,\n) {\n  const payload = {\n    query: query,\n    variables: variables,\n    operationName: operationName,\n  }\n\n  const result = await fetch(\n    process.env.SITE_ID,\n    {\n      method: 'POST',\n      headers: {\n        Authorization: accessToken ? \"Bearer \" + accessToken : '',\n      },\n      body: JSON.stringify(payload),\n    },\n  )\n\n  // @ts-ignore\n  return JSON.parse(result)\n}\n";
};
var subscriptionParserName = function (fn) { return "parseAndVerify" + fn.operationName + "Event"; };
var subscriptionFunctionName = function (fn) { return "subscribeTo" + fn.operationName; };
var exp = function (netlifyGraphConfig, name) {
    if (netlifyGraphConfig.moduleType === "commonjs") {
        return "exports." + name;
    }
    return "export const " + name;
};
var imp = function (netlifyGraphConfig, name, packageName) {
    if (netlifyGraphConfig.moduleType === "commonjs") {
        return "const " + name + " = require(\"" + packageName + "\")";
    }
    return "import " + name + " from \"" + packageName + "\"";
};
var generateSubscriptionFunctionTypeDefinition = function (schema, fn, fragments) {
    var parsingFunctionReturnSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperation)(schema, fn.parsedOperation, fragments);
    var variableNames = (fn.parsedOperation.variableDefinitions || []).map(function (varDef) { return varDef.variable.name.value; });
    var variableSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperationVariables)(variableNames, schema, fn.parsedOperation);
    var jsDoc = replaceAll(fn.description || "", "*/", "!")
        .split("\n")
        .join("\n* ");
    return "/**\n* " + jsDoc + "\n*/\nexport function " + subscriptionFunctionName(fn) + "(\n  /**\n   * This will be available in your webhook handler as a query parameter.\n   * Use this to keep track of which subscription you're receiving\n   * events for.\n   */\n  netlifyGraphWebhookId: string,\n  variables: " + variableSignature + ",\n  accessToken?: string | null\n  ) : void\n\n/**\n * Verify the " + fn.operationName + " event body is signed securely, and then parse the result.\n */\nexport function " + subscriptionParserName(fn) + " (/** A Netlify Handler Event */ event) : null | " + parsingFunctionReturnSignature + "\n";
};
exports.generateSubscriptionFunctionTypeDefinition = generateSubscriptionFunctionTypeDefinition;
// TODO: Handle fragments
var generateSubscriptionFunction = function (schema, fn, fragments) {
    var patchedWithWebhookUrl = (0, graphqlHelpers_1.patchSubscriptionWebhookField)({
        schema: schema,
        definition: fn.parsedOperation,
    });
    var patched = (0, graphqlHelpers_1.patchSubscriptionWebhookSecretField)({
        schema: schema,
        definition: patchedWithWebhookUrl,
    });
    // TODO: Don't allow unnamed operations as subscription
    var filename = (patched.name && patched.name.value) || "Unknown";
    var body = (0, graphql_1.print)(patched);
    var safeBody = replaceAll(body, "${", "\\${");
    return "const " + subscriptionFunctionName(fn) + " = async (\n  /**\n   * This will be available in your webhook handler as a query parameter.\n   * Use this to keep track of which subscription you're receiving\n   * events for.\n   */\n  netlifyGraphWebhookId,\n  variables,\n  accessToken,\n  ) => {\n    const netlifyGraphWebhookUrl = `${process.env.DEPLOY_URL}/.netlify/functions/" + filename + "?netlifyGraphWebhookId=${netlifyGraphWebhookId}`\n    const secret = process.env.NETLIFY_GRAPH_WEBHOOK_SECRET\n    const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}\n\n    const persistedInput = {\n      doc_id: \"" + fn.id + "\",\n      oeprationName: \"" + fn.operationName + "\",\n      variables: fullVariables,\n      accessToken: accessToken\n    }\n\n    const subscriptionOperationDoc = `" + safeBody + "`;\n\n    // const result = await fetchOneGraphPersisted(persistedInput)\n    const result = await fetchOneGraph(accessToken, subscriptionOperationDoc, \"" + fn.operationName + "\", fullVariables)\n}\n\nconst " + subscriptionParserName(fn) + " = (event) => {\n  if (!verifyRequestSignature({ event: event })) {\n    console.warn(\"Unable to verify signature for " + filename + "\")\n    return null\n  }\n  \n  return JSON.parse(event.body || '{}')\n}";
};
exports.generateSubscriptionFunction = generateSubscriptionFunction;
var makeFunctionName = function (kind, operationName) {
    if (kind === "query") {
        return "fetch" + capitalizeFirstLetter(operationName);
    }
    if (kind === "mutation") {
        return "execute" + capitalizeFirstLetter(operationName) + " ";
    }
    return capitalizeFirstLetter(operationName);
};
var queryToFunctionDefinition = function (fullSchema, persistedQuery) {
    var basicFn = {
        id: persistedQuery.id,
        operationString: persistedQuery.operationString,
        description: persistedQuery.description || "",
    };
    var body = basicFn.operationString;
    var safeBody = replaceAll(body, "${", "\\${");
    var parsed = (0, graphql_1.parse)(body);
    var operations = parsed.definitions.filter(function (def) { return def.kind === graphql_1.Kind.OPERATION_DEFINITION; });
    var fragments = parsed.definitions.filter(function (def) { return def.kind === graphql_1.Kind.FRAGMENT_DEFINITION; });
    if (!operations) {
        internalConsole_1.internalConsole.error("Operation definition is required in " + basicFn.id);
        return;
    }
    var operation = operations[0];
    if (operation.kind !== graphql_1.Kind.OPERATION_DEFINITION) {
        internalConsole_1.internalConsole.error("Definition is not an operation in " + basicFn.id);
        return;
    }
    var returnSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperation)(fullSchema, operation, fragments);
    var variableNames = (operation.variableDefinitions || []).map(function (varDef) { return varDef.variable.name.value; });
    var variableSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperationVariables)(variableNames, fullSchema, operation);
    var operationName = operation.name && operation.name.value;
    if (!operationName) {
        internalConsole_1.internalConsole.error("Operation name is required in " + basicFn.operationString + "\n\tfound: " + JSON.stringify(operation.name));
        return;
    }
    var operationWithoutNetlifyDirective = __assign(__assign({}, operation), { directives: (operation.directives || []).filter(function (directive) { return directive.name.value !== "netlify"; }) });
    var fn = __assign(__assign({}, basicFn), { fnName: makeFunctionName(operation.operation, operationName), safeBody: safeBody, kind: operation.operation, variableSignature: variableSignature, returnSignature: returnSignature, operationName: operationName, parsedOperation: operation, operationStringWithoutNetlifyDirective: (0, graphql_1.print)(operationWithoutNetlifyDirective) });
    return fn;
};
exports.queryToFunctionDefinition = queryToFunctionDefinition;
var generateJavaScriptClient = function (netlifyGraphConfig, schema, operationsDoc, enabledFunctions) {
    var operationsWithoutTemplateDollar = replaceAll(operationsDoc, "${", "\\${");
    var safeOperationsDoc = replaceAll(operationsWithoutTemplateDollar, "`", "\\`");
    var functionDecls = enabledFunctions.map(function (fn) {
        if (fn.kind === "subscription") {
            var fragments = [];
            return (0, exports.generateSubscriptionFunction)(schema, fn, fragments);
        }
        var dynamicFunction = exp(netlifyGraphConfig, fn.fnName) + " = (\n  variables,\n  accessToken,\n  ) => {\n  return fetchOneGraph({\n    query: `" + fn.safeBody + "`,\n    variables: variables,\n    accessToken: accessToken\n  })\n}\n\n  ";
        var staticFunction = exp(netlifyGraphConfig, fn.fnName) + " = (\n  variables,\n  accessToken,\n) => {\n  return fetchOneGraph(accessToken, operationsDoc, \"" + fn.operationName + "\", variables)\n}\n\n";
        return fn.id ? staticFunction : dynamicFunction;
    });
    var exportedFunctionsObjectProperties = enabledFunctions
        .map(function (fn) {
        var isSubscription = fn.kind === "subscription";
        if (isSubscription) {
            var subscriptionFnName = subscriptionFunctionName(fn);
            var parserFnName = subscriptionParserName(fn);
            var jsDoc_1 = replaceAll(fn.description || "", "*/", "")
                .split("\n")
                .join("\n* ");
            return "/**\n  * " + jsDoc_1 + "\n  */\n  " + subscriptionFnName + ":" + subscriptionFnName + ",\n  /**\n   * Verify the event body is signed securely, and then parse the result.\n   */\n  " + parserFnName + ": " + parserFnName;
        }
        var jsDoc = replaceAll(fn.description || "", "*/", "")
            .split("\n")
            .join("\n* ");
        return "/**\n  * " + jsDoc + "\n  */\n  " + fn.fnName + ": " + (netlifyGraphConfig.moduleType === "commonjs" ? "exports." : "") + fn.fnName;
    })
        .join(",\n  ");
    var dummyHandler = exp(netlifyGraphConfig, "handler") + " = async (event, context) => {\n  // return a 401 json response\n  return {\n    statusCode: 401,\n    body: JSON.stringify({\n      message: 'Unauthorized',\n    }),\n  }\n}";
    var source = "// GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!\n" + imp(netlifyGraphConfig, "https", "https") + "\n" + imp(netlifyGraphConfig, "crypto", "crypto") + "\n\n" + exp(netlifyGraphConfig, "verifySignature") + " = (input) => {\n  const secret = input.secret\n  const body = input.body\n  const signature = input.signature\n\n  if (!signature) {\n    console.error('Missing signature')\n    return false\n  }\n\n  const sig = {}\n  for (const pair of signature.split(',')) {\n    const [k, v] = pair.split('=')\n    sig[k] = v\n  }\n\n  if (!sig.t || !sig.hmac_sha256) {\n    console.error('Invalid signature header')\n    return false\n  }\n\n  const hash = crypto\n    .createHmac('sha256', secret)\n    .update(sig.t)\n    .update('.')\n    .update(body)\n    .digest('hex')\n\n  if (\n    !crypto.timingSafeEqual(\n      Buffer.from(hash, 'hex'),\n      Buffer.from(sig.hmac_sha256, 'hex')\n    )\n  ) {\n    console.error('Invalid signature')\n    return false\n  }\n\n  if (parseInt(sig.t, 10) < Date.now() / 1000 - 300 /* 5 minutes */) {\n    console.error('Request is too old')\n    return false\n  }\n\n  return true\n}\n\nconst operationsDoc = `" + safeOperationsDoc + "`\n\n" + generatedOneGraphClient() + "\n\n" + exp(netlifyGraphConfig, "verifyRequestSignature") + " = (request) => {\n  const event = request.event\n  const secret = process.env.NETLIFY_GRAPH_WEBHOOK_SECRET\n  const signature = event.headers['x-onegraph-signature']\n  const body = event.body\n\n  if (!secret) {\n    console.error(\n      'NETLIFY_GRAPH_WEBHOOK_SECRET is not set, cannot verify incoming webhook request'\n    )\n    return false\n  }\n\n  return verifySignature({ secret, signature, body: body || '' })\n}\n\n" + functionDecls.join("\n\n") + "\n  \n/**\n * The generated NetlifyGraph library with your operations\n */\nconst functions = {\n  " + exportedFunctionsObjectProperties + "\n}\n\n" + (netlifyGraphConfig.moduleType === "commonjs"
        ? "exports.default = functions"
        : "export default functions") + "\n\n" + dummyHandler;
    return source;
};
exports.generateJavaScriptClient = generateJavaScriptClient;
var generateTypeScriptDefinitions = function (netlifyGraphConfig, schema, enabledFunctions) {
    var functionDecls = enabledFunctions.map(function (fn) {
        var isSubscription = fn.kind === "subscription";
        if (isSubscription) {
            var fragments = [];
            return (0, exports.generateSubscriptionFunctionTypeDefinition)(schema, fn, fragments);
        }
        var jsDoc = replaceAll(fn.description || "", "*/", "")
            .split("\n")
            .join("\n* ");
        return "/**\n * " + jsDoc + "\n */\nexport function " + fn.fnName + "(\n  variables: " + fn.variableSignature + ",\n  accessToken?: string\n): Promise<\n  " + fn.returnSignature + "\n>;";
    });
    var source = "// GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!\n" + functionDecls.join("\n\n") + "\n";
    return source;
};
exports.generateTypeScriptDefinitions = generateTypeScriptDefinitions;
var generateFunctionsSource = function (netlifyGraphConfig, schema, operationsDoc, queries) {
    var functionDefinitions = Object.values(queries)
        .map(function (query) { return (0, exports.queryToFunctionDefinition)(schema, query); })
        .filter(Boolean);
    var clientSource = (0, exports.generateJavaScriptClient)(netlifyGraphConfig, schema, operationsDoc, functionDefinitions);
    var typeDefinitionsSource = (0, exports.generateTypeScriptDefinitions)(netlifyGraphConfig, schema, functionDefinitions);
    return {
        clientSource: clientSource,
        typeDefinitionsSource: typeDefinitionsSource,
        functionDefinitions: functionDefinitions,
    };
};
exports.generateFunctionsSource = generateFunctionsSource;
var pluckDirectiveArgValue = function (directive, argName) {
    var _a;
    var targetArg = (_a = directive === null || directive === void 0 ? void 0 : directive.arguments) === null || _a === void 0 ? void 0 : _a.find(function (arg) { return arg.name.value === argName; });
    if (!(targetArg && targetArg.value)) {
        return null;
    }
    if (targetArg.value.kind === graphql_1.Kind.STRING) {
        return targetArg.value.value;
    }
    return null;
};
/**
 * Extracts basic functions from a parsed GraphQL operations document
 * @param {DocumentNode} parsedDoc The parsed GraphQL document with @netlify directives
 * @returns Record<string, ExtractedFunction>
 */
var extractFunctionsFromOperationDoc = function (parsedDoc) {
    var functionEntries = parsedDoc.definitions
        .map(function (next) {
        var _a, _b;
        if (next.kind !== graphql_1.Kind.OPERATION_DEFINITION) {
            return null;
        }
        var key = ((_a = next.name) === null || _a === void 0 ? void 0 : _a.value) || "unknown";
        var directive = (_b = next.directives) === null || _b === void 0 ? void 0 : _b.find(function (localDirective) { return localDirective.name.value === "netlify"; });
        if (!directive) {
            return null;
        }
        var docString = pluckDirectiveArgValue(directive, "doc") || "";
        var id = pluckDirectiveArgValue(directive, "id");
        if (!id) {
            id = (0, uuid_1.v4)();
        }
        var nextWithoutNetlifyDirective = __assign(__assign({}, next), { directives: (next.directives || []).filter(function (directive) { return directive.name.value !== "netlify"; }) });
        var operation = {
            id: id,
            operationName: key,
            description: docString,
            parsedOperation: next,
            kind: next.operation,
            operationString: (0, graphql_1.print)(next),
            operationStringWithoutNetlifyDirective: (0, graphql_1.print)(nextWithoutNetlifyDirective),
        };
        return [id, operation];
    })
        .filter(Boolean);
    //@ts-ignore
    return Object.fromEntries(functionEntries);
};
exports.extractFunctionsFromOperationDoc = extractFunctionsFromOperationDoc;
var frameworkGeneratorMap = {
    "Next.js": nextjsExporter_1.nextjsFunctionSnippet.generate,
    default: genericExporter_1.netlifyFunctionSnippet.generate,
};
var defaultGenerator = genericExporter_1.netlifyFunctionSnippet.generate;
/**
 * Given a schema, GraphQL operations doc, a target operationId, and a Netlify Graph config, generates a set of handlers (and potentially components) for the correct framework.
 */
var generateHandlerSource = function (_a) {
    var handlerOptions = _a.handlerOptions, netlifyGraphConfig = _a.netlifyGraphConfig, operationId = _a.operationId, operationsDoc = _a.operationsDoc, schema = _a.schema;
    var parsedDoc = (0, graphql_1.parse)(operationsDoc);
    var operations = (0, exports.extractFunctionsFromOperationDoc)(parsedDoc);
    var fn = operations[operationId];
    if (!fn) {
        internalConsole_1.internalConsole.warn("Operation " + operationId + " not found in graphql.", Object.keys(operations));
        return;
    }
    var odl = (0, genericExporter_1.computeOperationDataList)({
        query: fn.operationString,
        variables: [],
    });
    var generate = frameworkGeneratorMap[netlifyGraphConfig.framework] || defaultGenerator;
    var exportedFiles = generate({
        netlifyGraphConfig: netlifyGraphConfig,
        operationDataList: odl.operationDataList,
        schema: schema,
        options: handlerOptions,
    }).exportedFiles;
    return { exportedFiles: exportedFiles, operation: fn.parsedOperation };
};
exports.generateHandlerSource = generateHandlerSource;
//# sourceMappingURL=netlifyGraph.js.map