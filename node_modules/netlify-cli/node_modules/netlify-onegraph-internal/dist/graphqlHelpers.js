"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formElComponent = exports.formInput = exports.patchSubscriptionWebhookSecretField = exports.patchSubscriptionWebhookField = exports.typeScriptSignatureForOperation = exports.typeScriptTypeNameForOperation = exports.typeScriptForOperation = exports.typeScriptDefinitionObjectForOperation = exports.listCount = exports.typeScriptSignatureForOperationVariables = exports.typeScriptForGraphQLType = exports.gatherVariableDefinitions = exports.gatherAllReferencedTypes = void 0;
var graphql_1 = require("graphql");
function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}
exports.default = capitalizeFirstLetter;
function gatherAllReferencedTypes(schema, query) {
    var types = new Set([]);
    var typeInfo = new graphql_1.TypeInfo(schema);
    (0, graphql_1.visit)(query, (0, graphql_1.visitWithTypeInfo)(typeInfo, {
        enter: function () {
            var fullType = typeInfo.getType();
            if (!!fullType) {
                var typ = (0, graphql_1.getNamedType)(fullType);
                if (typ)
                    types.add(typ.name.toLocaleLowerCase().replace("oneme", ""));
            }
        },
    }));
    var result = Array.from(types);
    return result;
}
exports.gatherAllReferencedTypes = gatherAllReferencedTypes;
function gatherVariableDefinitions(definition) {
    var _a;
    var extract = function (varDef) { return [
        varDef.variable.name.value,
        (0, graphql_1.print)(varDef.type),
    ]; };
    return (((_a = definition === null || definition === void 0 ? void 0 : definition.variableDefinitions) === null || _a === void 0 ? void 0 : _a.map(extract)) || []).sort(function (_a, _b) {
        var a = _a[0];
        var b = _b[0];
        return a.localeCompare(b);
    });
}
exports.gatherVariableDefinitions = gatherVariableDefinitions;
function typeScriptForGraphQLType(schema, gqlType) {
    var scalarMap = {
        String: "string",
        ID: "string",
        Int: "number",
        Float: "number",
        Boolean: "boolean",
    };
    if ((0, graphql_1.isListType)(gqlType)) {
        var subType = typeScriptForGraphQLType(schema, gqlType.ofType);
        return "Array<" + subType + ">";
    }
    else if ((0, graphql_1.isObjectType)(gqlType) || (0, graphql_1.isInputObjectType)(gqlType)) {
        var fields = Object.values(gqlType.getFields()).map(function (field) {
            var nullable = !(0, graphql_1.isNonNullType)(field.type);
            var type = typeScriptForGraphQLType(schema, field.type);
            var description = !!field.description
                ? "/**\n  * " + field.description + "\n  */\n  "
                : "";
            return description + "\"" + field.name + "\"" + (nullable ? "?" : "") + ": " + type;
        });
        return "{" + fields.join(", ") + "}";
    }
    else if ((0, graphql_1.isWrappingType)(gqlType)) {
        return typeScriptForGraphQLType(schema, gqlType.ofType);
    }
    else if ((0, graphql_1.isEnumType)(gqlType)) {
        var values = gqlType.getValues();
        var enums = values.map(function (enumValue) { return "\"" + enumValue.value + "\""; });
        return enums.join(" | ");
    }
    else {
        var namedType = (0, graphql_1.getNamedType)(gqlType);
        // @ts-ignore metaprogramming
        var basicType = scalarMap[namedType === null || namedType === void 0 ? void 0 : namedType.name] || "any";
        return basicType;
    }
}
exports.typeScriptForGraphQLType = typeScriptForGraphQLType;
function typeScriptSignatureForOperationVariables(variableNames, schema, operationDefinition) {
    var helper = function (variableDefinition) {
        var variableName = variableDefinition.variable.name.value;
        var result = [
            variableName,
            variableDefinition,
        ];
        return result;
    };
    var variables = (operationDefinition.variableDefinitions || [])
        .map(helper)
        .filter(function (_a) {
        var variableName = _a[0];
        return variableNames.includes(variableName);
    });
    var typesObject = variables.map(function (_a) {
        var varName = _a[0], varDef = _a[1];
        var printedType = (0, graphql_1.print)(varDef.type);
        var parsedType = (0, graphql_1.parseType)(printedType);
        //@ts-ignore
        var gqlType = (0, graphql_1.typeFromAST)(schema, parsedType);
        //@ts-ignore
        var tsType = typeScriptForGraphQLType(schema, gqlType);
        return [varName, tsType];
    });
    var typeFields = typesObject
        .map(function (_a) {
        var name = _a[0], tsType = _a[1];
        return "\"" + name + "\": " + tsType;
    })
        .join(", ");
    var types = "{" + typeFields + "}";
    return types === "" ? "null" : types;
}
exports.typeScriptSignatureForOperationVariables = typeScriptSignatureForOperationVariables;
//@ts-ignore
function listCount(gqlType) {
    var inspectedType = gqlType;
    var listCount = 0;
    var totalCount = 0;
    while ((0, graphql_1.isWrappingType)(inspectedType)) {
        if ((0, graphql_1.isListType)(inspectedType)) {
            listCount = listCount + 1;
        }
        totalCount = totalCount + 1;
        if (totalCount > 30) {
            console.warn("Bailing on potential infinite recursion");
            return -99;
        }
        inspectedType = inspectedType.ofType;
    }
    return listCount;
}
exports.listCount = listCount;
function typeScriptDefinitionObjectForOperation(schema, operationDefinition, fragmentDefinitions, shouldLog) {
    var _a;
    if (shouldLog === void 0) { shouldLog = true; }
    var scalarMap = {
        String: "string",
        ID: "string",
        Int: "number",
        Float: "number",
        Boolean: "boolean",
        GitHubGitObjectID: "string",
        // JSON: "JSON",
    };
    //@ts-ignore
    var helper = function (parentGqlType, selection) {
        var _a, _b, _c;
        if (!parentGqlType) {
            return;
        }
        var parentNamedType = 
        //@ts-ignore
        (0, graphql_1.getNamedType)(parentGqlType) || (0, graphql_1.getNamedType)(parentGqlType.type);
        var alias = (_a = selection.alias) === null || _a === void 0 ? void 0 : _a.value;
        var name = (_b = selection === null || selection === void 0 ? void 0 : selection.name) === null || _b === void 0 ? void 0 : _b.value;
        var displayedName = alias || name;
        //@ts-ignore
        var field = parentNamedType.getFields()[name];
        var gqlType = field === null || field === void 0 ? void 0 : field.type;
        if (name.startsWith("__")) {
            return [
                displayedName,
                { type: "any", description: "Internal GraphQL field" },
            ];
        }
        var namedType = (0, graphql_1.getNamedType)(gqlType);
        var isNullable = !(0, graphql_1.isNonNullType)(gqlType);
        var isList = (0, graphql_1.isListType)(gqlType) || (!isNullable && (0, graphql_1.isListType)(gqlType.ofType));
        var isObjectLike = (0, graphql_1.isObjectType)(namedType) ||
            (0, graphql_1.isUnionType)(namedType) ||
            (0, graphql_1.isInterfaceType)(namedType);
        var sub = (_c = selection.selectionSet) === null || _c === void 0 ? void 0 : _c.selections.map(function innerHelper(selection) {
            if (selection.kind === "Field") {
                return helper(namedType, selection);
            }
            else if (selection.kind === "InlineFragment") {
                var fragmentGqlType_1 = (0, graphql_1.typeFromAST)(schema, selection.typeCondition);
                if (!fragmentGqlType_1) {
                    return null;
                }
                var fragmentSelections = selection.selectionSet.selections.map(
                //@ts-ignore
                function (subSelection) {
                    var subSel = helper(fragmentGqlType_1, subSelection);
                    return subSel;
                });
                return fragmentSelections;
            }
            else if (selection.kind === "FragmentSpread") {
                var fragmentName = [selection.name.value];
                //@ts-ignore
                var fragment = fragmentDefinitions[fragmentName];
                if (fragment) {
                    var fragmentGqlType = (0, graphql_1.typeFromAST)(schema, fragment.typeCondition);
                    if (!fragmentGqlType) {
                        return null;
                    }
                    var fragmentSelections = fragment.selectionSet.selections.map(innerHelper);
                    return fragmentSelections;
                }
            }
            return null;
        }).filter(Boolean).reduce(function (acc, next) {
            if (Array.isArray(next[0])) {
                return acc.concat(next);
            }
            else {
                return __spreadArray(__spreadArray([], acc, true), [next], false);
            }
        }, []);
        var nestingLevel = isList ? listCount(gqlType) : 0;
        var isEnum = (0, graphql_1.isEnumType)(namedType);
        var basicType = isEnum
            ? //@ts-ignore
                new Set(namedType.getValues().map(function (gqlEnum) { return gqlEnum.value; }))
            : //@ts-ignore
                scalarMap[(namedType === null || namedType === void 0 ? void 0 : namedType.name) || "any"];
        var returnType;
        if (isObjectLike) {
            returnType = !!sub ? Object.fromEntries(sub) : null;
        }
        else if (basicType) {
            returnType = basicType;
        }
        else {
            returnType = "any";
        }
        if (returnType) {
            var finalType = returnType;
            for (var i = 0; i < nestingLevel; i++) {
                finalType = [finalType];
            }
            var entry = [
                displayedName,
                { type: finalType, description: field === null || field === void 0 ? void 0 : field.description },
            ];
            return entry;
        }
        //@ts-ignore
        console.warn("No returnType!", basicType, namedType.name, selection);
    };
    var baseGqlType = operationDefinition.kind === "OperationDefinition"
        ? operationDefinition.operation === "query"
            ? schema.getQueryType()
            : operationDefinition.operation === "mutation"
                ? schema.getMutationType()
                : operationDefinition.operation === "subscription"
                    ? schema.getSubscriptionType()
                    : null
        : operationDefinition.kind === "FragmentDefinition"
            ? //@ts-ignore
                schema.getType(operationDefinition.typeCondition.name.value)
            : null;
    var selections = (_a = operationDefinition.selectionSet) === null || _a === void 0 ? void 0 : _a.selections;
    var sub = selections === null || selections === void 0 ? void 0 : selections.map(function (selection) {
        return helper(baseGqlType, selection);
    });
    if (!!sub) {
        //@ts-ignore
        var object = Object.fromEntries(sub);
        var result = {
            data: {
                type: object,
                description: "Any data retrieved by the function will be returned here",
            },
            errors: {
                type: ["any"],
                description: "Any errors in the function will be returned here",
            },
        };
        return result;
    }
    else {
        return {
            data: {
                //@ts-ignore
                type: "any",
                description: "Any data retrieved by the function will be returned here",
            },
            errors: {
                type: ["any"],
                description: "Any errors in the function will be returned here",
            },
        };
    }
}
exports.typeScriptDefinitionObjectForOperation = typeScriptDefinitionObjectForOperation;
function typeScriptForOperation(schema, operationDefinition, fragmentDefinitions) {
    var typeMap = typeScriptDefinitionObjectForOperation(schema, operationDefinition, fragmentDefinitions);
    var valueHelper = function (value) {
        if ((value === null || value === void 0 ? void 0 : value.type) && typeof value.type === "string") {
            return value.type;
        }
        else if (Array.isArray(value.type)) {
            var subType = valueHelper({ type: value.type[0] });
            return "Array<" + subType + ">";
        }
        else if (value.type instanceof Set) {
            //@ts-ignore
            var enums = Array.from(value.type.values())
                .map(function (value) { return "\"" + value + "\""; })
                .join(" | ");
            return enums;
        }
        else if (typeof value.type === "object") {
            var fields_1 = objectHelper(value.type);
            return "{\n        " + fields_1.join(", ") + "\n    }";
        }
    };
    //@ts-ignore
    function objectHelper(obj) {
        return Object.entries(obj).map(function (_a) {
            var name = _a[0], value = _a[1];
            //@ts-ignore
            var type = value.type, description = value.description;
            //@ts-ignore
            var tsType = valueHelper(value);
            var doc = description
                ? "/**\n  * " + description + "\n  */\n  "
                : "";
            return doc + "\"" + name + "\": " + tsType;
        });
    }
    var fields = objectHelper(typeMap).join(", ");
    return "{" + fields + "}";
}
exports.typeScriptForOperation = typeScriptForOperation;
function typeScriptTypeNameForOperation(name) {
    return capitalizeFirstLetter(name) + "Payload";
}
exports.typeScriptTypeNameForOperation = typeScriptTypeNameForOperation;
function typeScriptSignatureForOperation(schema, operationDefinition, fragmentDefinitions) {
    var _a;
    var types = typeScriptForOperation(schema, operationDefinition, fragmentDefinitions);
    var name = ((_a = operationDefinition.name) === null || _a === void 0 ? void 0 : _a.value) || "unknown";
    return "" + types;
}
exports.typeScriptSignatureForOperation = typeScriptSignatureForOperation;
/**
 * Doesn't patch e.g. fragments
 */
function patchSubscriptionWebhookField(_a) {
    var _b;
    var schema = _a.schema, definition = _a.definition;
    if (definition.operation !== "subscription") {
        return definition;
    }
    var subscriptionType = schema.getSubscriptionType();
    if (!subscriptionType) {
        return definition;
    }
    var newSelections = definition.selectionSet.selections.map(function (selection) {
        var _a;
        if (selection.kind !== "Field")
            return selection;
        var field = subscriptionType.getFields()[selection.name.value];
        if (!field) {
            return selection;
        }
        var fieldHasWebhookUrlArg = field.args.some(function (arg) { return arg.name === "webhookUrl"; });
        var selectionHasWebhookUrlArg = (_a = selection.arguments) === null || _a === void 0 ? void 0 : _a.some(function (arg) { return arg.name.value === "webhookUrl"; });
        if (fieldHasWebhookUrlArg && !selectionHasWebhookUrlArg) {
            return __assign(__assign({}, selection), { arguments: __spreadArray(__spreadArray([], (selection.arguments || []), true), [
                    {
                        kind: "Argument",
                        name: {
                            kind: "Name",
                            value: "webhookUrl",
                        },
                        value: {
                            kind: "Variable",
                            name: {
                                kind: "Name",
                                value: "netlifyGraphWebhookUrl",
                            },
                        },
                    },
                ], false) });
        }
        return selection;
    });
    var hasWebhookVariableDefinition = (_b = definition.variableDefinitions) === null || _b === void 0 ? void 0 : _b.find(function (varDef) { return varDef.variable.name.value === "netlifyGraphWebhookUrl"; });
    var variableDefinitions = !!hasWebhookVariableDefinition
        ? definition.variableDefinitions
        : __spreadArray(__spreadArray([], (definition.variableDefinitions || []), true), [
            {
                kind: "VariableDefinition",
                type: {
                    kind: "NonNullType",
                    type: {
                        kind: "NamedType",
                        name: {
                            kind: "Name",
                            value: "String",
                        },
                    },
                },
                variable: {
                    kind: "Variable",
                    name: {
                        kind: "Name",
                        value: "netlifyGraphWebhookUrl",
                    },
                },
            },
        ], false);
    return __assign(__assign({}, definition), { 
        //@ts-ignore: Handle edge cases later
        variableDefinitions: variableDefinitions, 
        //@ts-ignore: Handle edge cases later
        selectionSet: __assign(__assign({}, definition.selectionSet), { selections: newSelections }) });
}
exports.patchSubscriptionWebhookField = patchSubscriptionWebhookField;
function patchSubscriptionWebhookSecretField(_a) {
    var _b;
    var schema = _a.schema, definition = _a.definition;
    if (definition.operation !== "subscription") {
        return definition;
    }
    var subscriptionType = schema.getSubscriptionType();
    if (!subscriptionType) {
        return definition;
    }
    var newSelections = definition.selectionSet.selections.map(function (selection) {
        var _a;
        if (selection.kind !== "Field")
            return selection;
        var field = subscriptionType.getFields()[selection.name.value];
        if (!field) {
            return selection;
        }
        var fieldHasWebhookSecretArg = field.args.some(function (arg) { return arg.name === "secret"; });
        var selectionHasWebhookSecretArg = (_a = selection.arguments) === null || _a === void 0 ? void 0 : _a.some(function (arg) { return arg.name.value === "secret"; });
        if (fieldHasWebhookSecretArg && !selectionHasWebhookSecretArg) {
            return __assign(__assign({}, selection), { arguments: __spreadArray(__spreadArray([], (selection.arguments || []), true), [
                    {
                        kind: "Argument",
                        name: {
                            kind: "Name",
                            value: "secret",
                        },
                        value: {
                            kind: "Variable",
                            name: {
                                kind: "Name",
                                value: "netlifyGraphWebhookSecret",
                            },
                        },
                    },
                ], false) });
        }
        return selection;
    });
    var hasWebhookVariableDefinition = (_b = definition.variableDefinitions) === null || _b === void 0 ? void 0 : _b.find(function (varDef) { return varDef.variable.name.value === "netlifyGraphWebhookSecret"; });
    var variableDefinitions = !!hasWebhookVariableDefinition
        ? definition.variableDefinitions
        : __spreadArray(__spreadArray([], (definition.variableDefinitions || []), true), [
            {
                kind: "VariableDefinition",
                type: {
                    kind: "NonNullType",
                    type: {
                        kind: "NamedType",
                        name: {
                            kind: "Name",
                            value: "OneGraphSubscriptionSecretInput",
                        },
                    },
                },
                variable: {
                    kind: "Variable",
                    name: {
                        kind: "Name",
                        value: "netlifyGraphWebhookSecret",
                    },
                },
            },
        ], false);
    return __assign(__assign({}, definition), { 
        //@ts-ignore: Handle edge cases later
        variableDefinitions: variableDefinitions, 
        //@ts-ignore: Handle edge cases later
        selectionSet: __assign(__assign({}, definition.selectionSet), { selections: newSelections }) });
}
exports.patchSubscriptionWebhookSecretField = patchSubscriptionWebhookSecretField;
var addLeftWhitespace = function (string, padding) {
    var paddingString = " ".repeat(padding);
    return string
        .split("\n")
        .map(function (line) { return paddingString + line; })
        .join("\n");
};
var formInput = function (schema, def, path) {
    if (path === void 0) { path = []; }
    var name = def.variable.name.value;
    function helper(path, type, subfield) {
        var isList = (0, graphql_1.isListType)(type);
        var namedType = (0, graphql_1.getNamedType)(type);
        var isEnum = (0, graphql_1.isEnumType)(namedType);
        var isObject = (0, graphql_1.isInputObjectType)(namedType);
        var isScalar = (0, graphql_1.isScalarType)(namedType);
        var subfieldName = subfield && subfield.name;
        var subDataEl;
        if (isList) {
            return helper(__spreadArray(__spreadArray([], path, true), [0], false), namedType, undefined);
        }
        else if (isObject) {
            // $FlowFixMe: we check this with `isObject` already
            var subFields_1 = namedType.getFields();
            if (!subFields_1) {
                return "MISSING_SUBFIELDS";
            }
            var subFieldEls = Object.keys(subFields_1)
                .map(function (fieldName) {
                var currentField = subFields_1[fieldName];
                var subPath = __spreadArray(__spreadArray([], path, true), [fieldName], false);
                var currentFieldInput = helper(subPath, currentField.type, currentField);
                return currentFieldInput;
            })
                .join("\n");
            return "<label>" + def.variable.name.value + "</label>\n  <fieldset>\n  " + addLeftWhitespace(subFieldEls, 2) + "\n  </fieldset>";
        }
        else if (isScalar) {
            var coerceFn = void 0;
            var inputAttrs = void 0;
            // $FlowFixMe: we check this with `isScalar` already
            switch (namedType.name) {
                case "String":
                    coerceFn = "(value) => value";
                    inputAttrs = [["type", "text"]];
                    break;
                case "Float":
                    coerceFn =
                        "(value) => try {return parseFloat(value)} catch (e) { return 0.0 }";
                    inputAttrs = [
                        ["type", "number"],
                        ["step", "0.1"],
                    ];
                    break;
                case "Int":
                    coerceFn =
                        "(value) => {try {return parseInt(value, 10)} catch (e) { return 0 }}";
                    inputAttrs = [["type", "number"]];
                    break;
                case "Boolean":
                    coerceFn = '(value) => value === "true"';
                    inputAttrs = [["type", "text"]];
                    break;
                default:
                    coerceFn = "(value) => value";
                    inputAttrs = [["type", "text"]];
                    break;
            }
            var updateFunction = "updateFormVariables(setFormVariables, " + JSON.stringify(path) + ", " + coerceFn + ")";
            subDataEl = "<label htmlFor=\"" + path.join("-") + "\">" + (subfieldName || def.variable.name.value) + "</label><input id=\"" + path.join("-") + "\" " + inputAttrs
                .map(function (_a) {
                var key = _a[0], value = _a[1];
                return key + "=\"" + value + "\"";
            })
                .join(" ") + " onChange={" + updateFunction + "} />";
        }
        else if (isEnum) {
            var updateFunction = "updateFormVariables(setFormVariables, " + JSON.stringify(path) + ", (value) => value)";
            var selectOptions = namedType
                // $FlowFixMe: we check this with `isEnum` already
                .getValues()
                .map(function (gqlEnum) {
                var enumValue = gqlEnum.value;
                var enumDescription = !!gqlEnum.description
                    ? ": " + gqlEnum.description
                    : "";
                return "<option value=\"" + enumValue + "\">" + gqlEnum.name + enumDescription + "</option>";
            })
                .join(" ");
            subDataEl = "<label htmlFor=\"" + path.join("-") + "\">" + def.variable.name.value + "</label><select id=\"" + path.join("-") + "\" onChange={" + updateFunction + "}> " + selectOptions + " </select>";
        }
        else {
            return "UNKNOWN_GRAPHQL_TYPE_FOR_INPUT";
        }
        return subDataEl;
    }
    var hydratedType = (0, graphql_1.typeFromAST)(schema, def.type);
    if (!hydratedType) {
        console.warn("\tCould not hydrate type for ", def.type);
        return null;
    }
    // const required = isNonNullType(hydratedType);
    var formEl = helper([name], hydratedType, undefined);
    return "" + formEl;
};
exports.formInput = formInput;
var formElComponent = function (_a) {
    var operationData = _a.operationData, schema = _a.schema, callFn = _a.callFn;
    if (!schema) {
        return {
            formHelpers: "const [formVariables, setFormVariables] = React.useState({});",
            formEl: "<pre>You must pass in a schema to generate forms for your GraphQL operation</pre>",
        };
    }
    var els = (operationData.operationDefinition.variableDefinitions || []).map(function (def) {
        var genInput = (0, exports.formInput)(schema, def, []);
        var input = genInput || "UNABLE_TO_GENERATE_FORM_INPUT_FOR_GRAPHQL_TYPE(" + def + ")";
        return "" + input;
    });
    return {
        formHelpers: "const [formVariables, setFormVariables] = React.useState({});",
        formEl: "<form onSubmit={event => { event.preventDefault(); " + callFn + " }}>\n  " + addLeftWhitespace(els.join("\n"), 2) + "\n    <input type=\"submit\" />\n  </form>",
    };
};
exports.formElComponent = formElComponent;
//# sourceMappingURL=graphqlHelpers.js.map